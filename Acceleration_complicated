from machine import Pin, I2C
import time

# ==================== I2C ====================
i2c = I2C(0, scl=Pin(21), sda=Pin(20), freq=400000)
BME280_ADDR = 0x76

# ==================== BME280 ====================
def bme280_init():
    i2c.writeto_mem(BME280_ADDR, 0xF2, b'\x01')
    i2c.writeto_mem(BME280_ADDR, 0xF4, b'\x27')

def read_calibration():
    cal = i2c.readfrom_mem(BME280_ADDR, 0x88, 24)
    dig_T1 = cal[1] << 8 | cal[0]
    dig_T2 = cal[3] << 8 | cal[2]
    if dig_T2 > 32767: dig_T2 -= 65536
    dig_T3 = cal[5] << 8 | cal[4]
    if dig_T3 > 32767: dig_T3 -= 65536

    dig_P1 = cal[7] << 8 | cal[6]
    dig_P2 = cal[9] << 8 | cal[8]
    if dig_P2 > 32767: dig_P2 -= 65536
    dig_P3 = cal[11] << 8 | cal[10]
    if dig_P3 > 32767: dig_P3 -= 65536
    dig_P4 = cal[13] << 8 | cal[12]
    if dig_P4 > 32767: dig_P4 -= 65536
    dig_P5 = cal[15] << 8 | cal[14]
    if dig_P5 > 32767: dig_P5 -= 65536
    dig_P6 = cal[17] << 8 | cal[16]
    if dig_P6 > 32767: dig_P6 -= 65536
    dig_P7 = cal[19] << 8 | cal[18]
    if dig_P7 > 32767: dig_P7 -= 65536
    dig_P8 = cal[21] << 8 | cal[20]
    if dig_P8 > 32767: dig_P8 -= 65536
    dig_P9 = cal[23] << 8 | cal[22]
    if dig_P9 > 32767: dig_P9 -= 65536

    return (dig_T1, dig_T2, dig_T3,
            dig_P1, dig_P2, dig_P3,
            dig_P4, dig_P5, dig_P6,
            dig_P7, dig_P8, dig_P9)

def read_pressure(cal):
    data = i2c.readfrom_mem(BME280_ADDR, 0xF7, 6)

    adc_p = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)
    adc_t = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4)

    var1 = ((adc_t >> 3) - (cal[0] << 1)) * cal[1] >> 11
    var2 = (((adc_t >> 4) - cal[0]) * ((adc_t >> 4) - cal[0]) >> 12) * cal[2] >> 14
    t_fine = var1 + var2

    var1 = t_fine - 128000
    var2 = var1 * var1 * cal[8]
    var2 = var2 + ((var1 * cal[7]) << 17)
    var2 = var2 + (cal[6] << 35)
    var1 = ((var1 * var1 * cal[5]) >> 8) + ((var1 * cal[4]) << 12)
    var1 = ((1 << 47) + var1) * cal[3] >> 33

    if var1 == 0:
        return 0

    p = 1048576 - adc_p
    p = (((p << 31) - var2) * 3125) // var1
    var1 = (cal[11] * (p >> 13) * (p >> 13)) >> 25
    var2 = (cal[10] * p) >> 19
    p = ((p + var1 + var2) >> 8) + (cal[9] << 4)

    return p / 25600.0  # hPa

# ==================== ALTITUDE ====================
def pressure_to_altitude(pressure, p0):
    return 44330 * (1 - (pressure / p0) ** 0.1903)

# ==================== MAIN ====================
print("Initializing...")
bme280_init()
time.sleep(1)
cal = read_calibration()

print("Calibrating ground pressure...")
time.sleep(2)
P0 = read_pressure(cal)
print("Ground pressure:", P0)

previous_altitude = 0
previous_time = time.ticks_ms()

launch_detected = False
drop_detected = False

# Thresholds (tune for your rocket)
movement_threshold = 0.5      # m/s to count as moving
spike_threshold = 5.0         # m/s sudden spike = launch/drop

print("\nMonitoring...\n")

while True:
    current_time = time.ticks_ms()
    dt = (time.ticks_diff(current_time, previous_time)) / 1000

    pressure = read_pressure(cal)
    altitude = pressure_to_altitude(pressure, P0)

    vertical_speed = (altitude - previous_altitude) / dt

    previous_altitude = altitude
    previous_time = current_time

    # Determine movement state
    if vertical_speed > movement_threshold:
        state = "MOVING UP"
    elif vertical_speed < -movement_threshold:
        state = "MOVING DOWN"
    else:
        state = "STATIONARY"

    print("Vertical:", state)

    # Spike detection
    if vertical_speed > spike_threshold and not launch_detected:
        print("ðŸš€ LAUNCH DETECTED")
        launch_detected = True

    if vertical_speed < -spike_threshold and not drop_detected:kk
        print("ðŸª‚ DROP DETECTED")
        drop_detected = True

    time.sleep(0.2)
